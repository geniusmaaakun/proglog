k8sを使ったログを追加したり、取得したりできるツールの開発。
クラスタでレプリケーションをする。
serfでクラスタを形成し、Raftを使ってレプリカの合意形成（連携）を行う

1 LetsGO

2 プロトコルバッファによる構造化データ
非公開APIではJSONよりもプロトコルバッファの方がいいケースがある。

プロトコルバッファを使う理由
型の安全性を保証
スキーマ違反を防ぐ
高速なシリアライズ
後方互換性を提供

便利な機能
一貫性のあるスキーマ
バージョン管理
ボイラープレートコードの削減　手書きしない
拡張性
言語寛容性　様々な言語でサポート
パフォーマンス　最大6倍速

プロトコルバッファのコンパイル

3 ログパッケージの作成
主にコードの実装

4 gRPCリクエスト処理
gRPCでサービスを作るにはprotobufでサービスを定義し、プロトコルバッファをクライアントとサーバーのスタブコードへとコンパイルする
その後サーバーを実装する。
internalパッケージは隣接するディレクトリからしかインポートできない。内部パッケージになる
gRPCが構成するコードは短く簡単。ネットワークとログのコードがきれいに分離できているため

gRPCでのエラー処理
statusパッケージを使うことで優れたエラー処理ができる

5 安全なサービスの構築
セキュリティをあとから追加するのは大変

3ステップ
通信データの暗号化 TLS
クライアントの認証 クライアント証明書
権限の認可　ACL

CFSSLというツールを使う

6 システムの観測
自分のシステムに何が起きているのかを観測できるようにする
メトリクス
何件のリクエストが失敗したのか、各リクエストの処理に要した時間など、時間の経過とともに数値データを測定したもの
{
    レイテンシー（遅延時間）
    トラフィック
    エラー
    サーチュレーション（サービスの容量）
}
構造化ログによって、有益な情報を見やすくまとめる。
ログをkafkaなどに集めて見る

メトリクスや構造化ログ、トレースを外部サービスに送信するようにして、観測できるようにする


7 サーバー間のサービスディスカバリ
クラスタへの追加、削除をできるようにする
クラスタ内のサーバーを見つける。サービスディスカバリー
サービスの複製のインスタンスを実行し、互いのサービスを発見し、データを複製できる

8 合意形成によるサービス連携
コンセンサスアルゴリズム。
7章ではレプリケーションを実装したが、同じデータを無限にコピーする循環に陥って、互いに複製し合うことになっていた。
サーバーをリーダーとフォロワーの関係にしてフォロワーがリーダーのデータを複製するようにする。
Raftを使う。

9 サーバーディスカバリとクライアント側ロードバランス
サービスの可用性、拡張性、ユーザー体験を向上させる

10 k8sでローカルにアプリケーションをデプロイ
・CLIを作成し、サービスを実行するための実行ファイルを用意する
・k8sとHelmを設定し、ローカルマシンとクラウドプラットフォームの両方でサービスをオーケストレーションできるようにする
・ローカルマシンでサービスのクラスタを実行する

Cobraを使ってCLIを構築
Kindを使ってK8sDockerコンテナをクラスタにセットアップする
Helmを使ってk8sにサービスを配布、インストールできる



11　アプリケーションをk8sでクラウドにデプロイ
GKEを使う。12ヶ月無料
Metacontrollerを使う。K8sとのやり取りを処理してくれる